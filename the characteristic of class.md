# 面对对象中类的三大特征

## 1 继承
在编写类时，并非总是要从空白开始，如果编写的类是另一种类的特殊版本的时候，我们可以使用继承。一个类继承另一个类时，新类会获得另一个类的所有属性和方法。
原类称为父类，新类称为子类。子类可以继承父类的所有属性和方法，同时也可以定义自己的属性和方法。

### 1.1 子类接受父类的__init__()
创建子类时父类要包含在文件中，且位于子类前面。
```
>>> class Old():   ## 这里的代码格式有问题
>>> def __init__(self,a,b,c):
        ......
>>> class New():
>>> def __init__(self,a,b,c):
>>>     super().__init__(a,b,c)
```
父类也成为超类（superclass），故super得名。

### 1.2 给子类定义属性和方法
子类继承父类后，可添加区分子类与父类的新属性和方法。
```
>>> class Old():
>>> def __init__(self,a,b,c):
        ......
>>> class New():
>>> def __init__(self,a,b,c):
>>>     super().__init__(a,b,c)
>>>     self.new_way = new_way
```
这样就在New类中添加了一个新属性self.new_way，并设置其初始值为new_way，但Old类中不包含这一个新类。

## 2. 多态
多态是同一类事物具有的多种形态。多态是面向对象编程的重要特点之一。

### 2.1Python本身就是一种多态语言
```
>>> def add(a,b):
>>>     return a+b
>>> print(add(100,200))
300
>>> print(add('hello','world'))
helloworld
>>> print(add([100,200],[100,200]))
[100,200,100,200]
```
例如：参数a和b可以接收不同的数据类型。当a和b同时是数字类型时，add()函数将进行加法运算;当a和b同时是字符串类型或列表类型时，add()函数将进行拼接运算。

### 2.2多态的作用
让具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容(功能)的函数。
## 2.3多态的特点
1、只关心对象的实例方法是否同名，不关心对象所属的类型；
2、对象所属的类之间，继承关系可有可无；
3、多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；
4、多态是调用方法的技巧，不会影响到类的内部设计。

## 3. 封装
“封装”就是将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体（即类）；封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。
```
>>> class A():
>>>     def __init__(self,a, b): 
>>>         self.a = a
>>>         self.b = b
>>>     def print_b(self):
>>>         print("{self.a}{self.score}")
>>> May = A("m",90)        
>>> Peter = A("n",85)        
```
定义类的方法：除了第一个参数是self外，其他和普通函数一样。

实例调用方法：只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入；注意，若类的方法仅需要self，不需要其他，调用该方法时，仅需 instance_name.function_name()

　　这样一来，我们从外部看A类，就只需要知道，创建实例需要给出a和b，而如何打印，都是在A类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。
  ### 3.1封装的特点
1、 子类的封装属性或方法并不会覆盖父类的封装属性或方法

2、 子类或父类的封装属性或封装方法是语法上变形过了

3、类的封装不是真正意义上的“私有化”，而是一个语法上的变形

4、类的封装属性或方式，其实在定义阶段就已经进行了语法上的变形

5、类的调用阶段，再进行封装语法已经没有任何用处了
